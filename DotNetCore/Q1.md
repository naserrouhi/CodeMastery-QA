<details>
<summary>Q1</summary>

## Q1: What is .Net Core?

.NET Core is a **open-source** and **cross-platform framework** developed by Microsoft. .NET Core is optimized for **high performance**, especially in web applications, and is designed to be **cloud-ready** with tight integration for building, deploying, and scaling cloud services.

</details>

<details>
<summary>Q1-1</summary>

## Q1-1: What is CLR?

The Common Language Runtime (CLR) is the virtual machine component of Microsoft's .NET framework. It provides a managed execution environment for .NET applications, handling tasks such as memory management, security, and exception handling. Here are some key functions and features of the CLR:

1. **Memory Management**: The CLR includes a **garbage collector (GC)** that automatically handles memory allocation and deallocation, helping to prevent memory leaks and optimize resource usage.

2. **Type Safety**: The CLR enforces type safety, ensuring that code adheres to type rules and preventing type-related errors and vulnerabilities.

3. **Exception Handling**: It provides a structured approach to handling exceptions, allowing for robust error management and recovery within applications.

4. **Security**: The CLR includes a security model that enforces code access security (CAS) and provides mechanisms for defining and enforcing security policies.

5. **Just-In-Time (JIT) Compilation**: The CLR compiles **intermediate language (IL)** code into native machine code at runtime, optimizing performance and enabling cross-platform compatibility.

6. **Interoperability**: It provides mechanisms for interacting with unmanaged code and other programming environments, enabling integration with existing libraries and applications.

7. **Thread Management**: The CLR manages and schedules threads, providing support for multithreading and parallelism in .NET applications.

Overall, the CLR is a key component of the .NET ecosystem, providing a managed execution environment that simplifies development, enhances security, and improves performance.

</details>

<details>
<summary>Q1-2</summary>

## Q1-2: What is RyuJIT?

RyuJIT is the Just-In-Time (JIT) compiler used in the .NET framework, starting from .NET Framework 4.6 and .NET Core. It replaces the older JIT compiler, known as the "MSIL JIT," and is designed to improve performance and efficiency in the compilation of Intermediate Language (IL) code to native machine code.

</details>

<details>
<summary>Q1-3</summary>

## Q1-3: What is framework?

A framework is a pre-built collection of libraries, tools, and conventions that provides a structured environment for building applications. It offers reusable code and predefined architecture that developers can use to solve common programming problems, allowing them to focus on the unique aspects of their application rather than reinventing the wheel.

**Example**: Imagine you're building a house. A framework is like having pre-cut pieces of wood, blueprints, and tools that show you exactly how to put the house together. It makes the building process faster and easier.

</details>

<details>
<summary>Q1-4</summary>

## Q1-4: What is virtual machine component?

A virtual machine component is a software layer that enables the execution of applications in a controlled, platform-independent environment. It abstracts the underlying hardware and provides services like memory management, security, and portability, ensuring that applications can run consistently across different systems.

</details>

<details>
<summary>Q1-5</summary>

## Q1-5: What is platform?

A platform is the foundation that supports the development, deployment, and execution of software applications. It encompasses hardware, operating systems, and software frameworks, providing the necessary environment for applications to function.

**Example**: Think of your smartphone. The platform includes the phone itself (the hardware), the operating system (Android), and the app store. All apps you download and use are built to work on this platform.

</details>

<details>
<summary>Q1-6</summary>

## Q1-6: Is .Net a platform or framework?

- **.NET as a Platform**: Refers to the broader environment that includes runtime, operating systems, and a collection of frameworks and tools for building and running applications across different environments.
  
- **.NET as a Framework**: Refers to specific sets of tools and libraries within the .NET platform that are used to build applications in particular domains.

In general, **.NET** is often referred to as a platform because it encompasses everything needed to develop and run applications across multiple environments and supports a wide range of frameworks under its umbrella.

</details>

<details>
<summary>Q1-7</summary>

## Q1-7: What is the difference between platform and framework?

* **Platform** is where you run your applications. It's the entire environment, including hardware and software.
* **Framework** is a tool you use to build applications. It gives you a structured way to create something that can run on a platform.

</details>

<details>
<summary>Q1-8</summary>

## Q1-8: What is CAS?

CAS (Code Access Security) is a security model in the .NET Framework that controls what code can do based on where it comes from and other identity factors. It helps protect systems from untrusted or potentially harmful code by restricting its permissions.

</details>

<details>
<summary>Q1-9</summary>

## Q1-9: What security mechanisms or practices replace CAS in .NET Core??

In .NET Core and later versions (like .NET 5, .NET 6, and .NET 7), **Code Access Security (CAS)** is not supported. Instead of CAS, .NET Core uses other security practices and models to ensure application security. Here's what is used instead:

### 1. Operating System-Level Security:
   - **Permissions and Access Control**: In .NET Core, security is more tightly integrated with the underlying operating system. Permissions and access control are handled by the OS, so developers rely on the OS to enforce security boundaries, such as file system access, network access, and execution permissions.
   - **Principle of Least Privilege**: Applications are often run with the minimum necessary privileges. For example, services might run under specific user accounts with limited permissions, ensuring that even if a vulnerability is exploited, the damage is contained.

### 2. Sandboxing and Containers:
   - **Containers (e.g., Docker)**: Containers are a modern approach to isolating applications. By running .NET Core applications inside containers, you can create a sandboxed environment where the application is isolated from the host system. This limits the potential damage if the application is compromised.
   - **App Sandbox (macOS and iOS)**: On platforms like macOS and iOS, applications run in a sandbox, which restricts what they can do based on predefined policies.

### 3. AssemblyLoadContext:
   - **Custom Assembly Loading**: .NET Core introduces `AssemblyLoadContext`, which allows for more granular control over assembly loading. This can be used to create isolated environments within a .NET Core application, somewhat similar to the way Application Domains were used in .NET Framework, but without the full overhead of CAS.

### 4. Role-Based Access Control (RBAC) and Claims-Based Security:
   - **Identity and Access Management**: In web applications, security models often rely on Role-Based Access Control (RBAC) or Claims-Based Security. These models use user roles and claims (pieces of user information) to enforce security policies.
   - **ASP.NET Core Identity**: ASP.NET Core provides a robust identity system that supports authentication and authorization, allowing developers to define what actions different users or roles can perform.

### 5. Dependency Injection and Secure Coding Practices:
   - **Dependency Injection**: .NET Core heavily uses dependency injection, which helps manage dependencies and can be used to enforce security policies by controlling what components are available to the application.
   - **Secure Coding Practices**: Emphasis is placed on secure coding practices, such as input validation, output encoding, and avoiding common vulnerabilities (e.g., SQL injection, cross-site scripting).

### 6. Security Libraries and APIs:
   - **System.Security.Cryptography**: .NET Core includes the `System.Security.Cryptography` namespace, which provides a range of cryptographic functions for encryption, hashing, and secure data handling.
   - **JWT Tokens**: In web applications, JSON Web Tokens (JWT) are commonly used for secure, stateless authentication and authorization.

### Summary:
In .NET Core, instead of relying on CAS, security is achieved through a combination of operating system-level controls, containerization, role-based and claims-based security, dependency injection, secure coding practices, and modern security libraries. This approach is more aligned with contemporary security practices and allows .NET Core applications to be more flexible and secure in a variety of environments.

</details>

<details>
<summary>Q1-10</summary>

## Q1-10: What is CLI?

A Command-Line Interface (CLI) is a text-based interface that allows users to interact with an operating system or software by typing commands. It provides a powerful, flexible, and resource-efficient way to perform tasks, manage systems, and automate processes.

</details>

<details>
<summary>Q1-11</summary>

## Q1-11: What is .Net CLI?

The .NET CLI is a powerful command-line tool that supports .NET developers in creating, building, running, testing, and managing .NET applications across different platforms.

**Example:**
```sh
dotnet build MyConsoleApp
```

</details>

<details>
<summary>Q1-12</summary>

## Q1-12: What is CIL?

Common Intermediate Language (CIL) is a low-level, language-independent code used by the .NET Framework. It acts as an intermediate step between high-level programming languages and the native machine code executed by the hardware. CIL allows .NET applications to be portable and ensures interoperability between different .NET languages.

**Compilation Process:**

* **Source Code**: High-level source code written in a .NET language (e.g., C# or VB.NET) is first compiled into CIL by a language-specific compiler (e.g., the C# compiler csc).
* **Assembly**: The resulting CIL code is stored in an assembly, which is a compiled code library containing CIL and metadata.
* **Just-In-Time (JIT) Compilation**: When the application is run, the CLR�s JIT compiler converts the CIL code into native machine code specific to the hardware on which the application is running.

**Example:**

```cil
.assembly Program {}
.class public Program
{
    .method public static void Main()
    {
        .entrypoint
        // Code to write "Hello, World!" to the console
        ldstr "Hello, World!"
        call void [System.Console]System.Console::WriteLine(string)
        ret
    }
}
```

</details>

<details>
<summary>Q1-13</summary>

## Q1-13: What is BCL?

Base Class Library (BCL) is a subset of the FCL, focused on providing the fundamental types and classes needed for basic .NET applications.

</details>

<details>
<summary>Q1-14</summary>

## Q1-14: What is FCL?

Framework Class Library (FCL) is a comprehensive collection of classes, interfaces, and value types provided by the .NET Framework such as file operations, data access, network communication, and graphical user interfaces.\
It offers a wide range of functionalities to simplify development tasks and promote code reuse. By using the FCL, developers can efficiently build applications without having to write common functionalities from scratch.\
The FCL provides a consistent and integrated development experience across different .NET languages and platforms.

FCL includes the BCL but also offers additional libraries and APIs for more specialized and advanced tasks, including web development, data access, GUI development, and more.

**Namespace Examples:**\
System, System.IO, System.Collections, System.Net, System.Linq, System.Threading

</details>

<details>
<summary>Q1-15</summary>

## Q1-15: What is API?

An API (Application Programming Interface) is a set of protocols and tools that allows different software applications to communicate and interact with each other.

</details>

<details>
<summary>Q1-16</summary>

## Q1-16: How many API types do we have?

1. **Web APIs**:
   - **REST (Representational State Transfer)**: A popular architectural style for web APIs that uses standard HTTP methods and focuses on resources identified by URLs. Responses are often in JSON or XML format.

   - **SOAP (Simple Object Access Protocol)**: A protocol for exchanging structured information using XML. It is more rigid than REST and includes a set of rules for request and response formats.

     **Example Request**:

     ```xml
     <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:urn="urn:ebay:api:PayPalAPI">
       <soapenv:Header/>
       <soapenv:Body>
         <urn:GetBalanceReq>
           <urn:GetBalanceRequest>
             <urn:Version>94.0</urn:Version>
             <urn:Credential>
               <urn:Username>your-username</urn:Username>
               <urn:Password>your-password</urn:Password>
             </urn:Credential>
           </urn:GetBalanceRequest>
         </urn:GetBalanceReq>
       </soapenv:Body>
     </soapenv:Envelope>
     ```

     **Example Response**:

     ```xml
     <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
       <soapenv:Body>
         <GetBalanceResponse xmlns="urn:ebay:api:PayPalAPI">
           <Balance>100.00</Balance>
           <CurrencyCode>USD</CurrencyCode>
         </GetBalanceResponse>
       </soapenv:Body>
     </soapenv:Envelope>
     ```

   - **GraphQL**: A query language for APIs that allows clients to request exactly the data they need, and nothing more. It provides more flexibility compared to REST.
    
     **Example Request**:

     ```graphql
     query {
       repository(owner:"octocat", name:"Hello-World") {
         issues(last:20, states:CLOSED) {
           edges {
             node {
               title
               url
               labels(first:5) {
                 edges {
                   node {
                     name
                   }
                 }
               }
             }
           }
         }
       }
     }
     ```

     **Example Response**:

     ```json
     {
       "data": {
         "repository": {
           "issues": {
             "edges": [
               {
                 "node": {
                   "title": "Found a bug",
                   "url": "https://github.com/octocat/Hello-World/issues/1347",
                   "labels": {
                     "edges": [
                       {
                         "node": {
                           "name": "bug"
                         }
                       }
                     ]
                   }
                 }
               }
             ]
           }
         }
       }
     }
     ```

2. **Library or Framework APIs**:
   - **Function Calls**: APIs that provide functions or methods for interacting with a software library or framework. For example, the .NET Framework provides APIs for file I/O, database access, and more.

   ```csharp
   // Using .NET's File class to read a file
   string content = File.ReadAllText("example.txt");
   ```

3. **Operating System APIs**:
   - **System Calls**: APIs provided by operating systems to interact with hardware and system resources. For example, Windows API (WinAPI) provides functions for managing windows, files, and hardware.

4. **Database APIs**:
   - **Database Query Interfaces**: APIs that allow applications to interact with databases, such as SQL-based APIs for executing queries and retrieving results.

    ```sql
    SELECT * FROM Users WHERE UserID = 1;
    ```

    ```javascript
    db.users.find({ "username": "johndoe" });
    ```

</details>

<details>
<summary>Q1-17</summary>

## Q1-17: What is JWT?

**JWT** stands for **JSON Web Token**. It is an open standard (RFC 7519) used for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs are commonly used for authentication and authorization purposes in web applications.

### Key Components of JWT:

A JWT consists of three parts, typically separated by dots (`.`):
1. **Header**
2. **Payload**
3. **Signature**

#### 1. **Header**:
   - **Content**: The header typically consists of two parts: the type of the token (which is JWT) and the signing algorithm being used, such as HMAC SHA256 or RSA.
   - **Example**:
     ```json
     {
       "alg": "HS256",
       "typ": "JWT"
     }
     ```

#### 2. **Payload**:
   - **Content**: The payload contains the claims, which are statements about an entity (typically, the user) and additional data. There are three types of claims:
     - **Registered claims**: Predefined claims like `iss` (issuer), `exp` (expiration time), and `sub` (subject).
     - **Public claims**: Claims that are defined in the JWT standard but can be used by anyone. They should be used with caution to avoid conflicts.
     - **Private claims**: Custom claims created by the developers that are specific to their application.
   - **Example**:
     ```json
     {
       "sub": "1234567890",
       "name": "John Doe",
       "admin": true
     }
     ```

#### 3. **Signature**:
   - **Content**: To create the signature, the encoded header, encoded payload, a secret key, and the algorithm specified in the header are combined. The signature ensures that the token hasn't been altered.
   - **Example**:
     - If using HMAC SHA256:
     ```text
     HMACSHA256(
       base64UrlEncode(header) + "." +
       base64UrlEncode(payload),
       secret)
     ```

### Benefits of JWT:
- **Stateless**: JWTs are self-contained; all the information needed for verification is within the token, eliminating the need for session state on the server.
- **Scalable**: Since JWTs are stateless, they are ideal for distributed systems where the authentication server might be separate from other parts of the application.
- **Compact and Efficient**: JWTs are compact and can be easily transmitted via URLs, headers, or within POST parameters.
- **Secure**: JWTs can be signed and optionally encrypted to ensure data integrity and confidentiality.

</details>

<details>
<summary>Q1-18</summary>

## Q1-18: What is Token?

A token is a piece of data used to authenticate or authorize actions within a system.

</details>

<details>
<summary>Q1-19</summary>

## Q1-19: Explain types of tokens.

1. **Authentication Token**:
   - **Description**: Represents a user's identity and is used to verify that the user is authenticated. Once the user logs in, an authentication token is issued and can be used to access protected resources without needing to repeatedly send credentials.
   - **Example**: JWT

2. **Access Token**:
   - **Description**: Represents the authorization to access specific resources. Access tokens are issued after successful authentication.
   - **Example**: In OAuth 2.0, an access token is issued after the user grants permission to access certain resources.

3. **Refresh Token**:
   - **Description**: A long-lived token that is used to request a new access token once the previous one expires.
   - **Example**: In OAuth 2.0, a refresh token is issued alongside an access token.

4. **Bearer Token**:
   - **Description**: A type of token where the possession of the token grants access to a resource. The bearer token is typically included in the HTTP Authorization header.
   - **Example**: Most APIs that require access tokens expect them to be passed in the form of a bearer token.

5. **CSRF Token (Cross-Site Request Forgery Token)**:
   - **Description**: Used to protect against CSRF attacks, where an attacker tries to perform unauthorized actions on behalf of a user. CSRF tokens are unique to each session and must be included in forms or requests to validate that the request is legitimate.
   - **Example**: Many web applications include a hidden CSRF token in forms that the server checks to verify the request.

6. **Session Token**:
   - **Description**: Used to maintain the session state between a client and a server. After a user logs in, a session token is generated and stored on the client (typically in cookies) to identify and authenticate the user for the duration of the session.
   - **Example**: In traditional web apps, when a user logs in, the server generates a session token, stores it in a cookie, and associates it with the user's session.

</details>

<details>
<summary>Q1-20</summary>

## Q1-20: Name some alternatives to Bearer tokens.

1. **Basic Authentication**:
   - **Description**: Sends the user’s credentials (username and password) encoded in base64 in the HTTP Authorization header. It is a very simple but less secure form of authentication because the credentials can be easily decoded if not transmitted over HTTPS.
   - **Example**:
     ```http
     Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=
     ```

2. **API Key Authentication**:
   - **Description**: Involves sending a unique API key as part of the request, either in a header, as a query parameter, or in the body of the request. API keys are usually associated with a user or an application and are commonly used in web services.
   - **Example** (using a query parameter):
     ```http
     GET https://api.example.com/resource?api_key=your_api_key
     ```

3. **OAuth 1.0a**:
   - **Description**: A more complex authentication method where the token is signed with both a consumer secret and a token secret. OAuth 1.0a requires signatures to verify the authenticity of requests, making it more secure than bearer tokens but also more complex to implement.
   - **Example**: Instead of just using a token, OAuth 1.0a involves signatures that prevent tampering with the request.
     ```http
     Authorization: OAuth oauth_consumer_key="key", oauth_token="token", oauth_signature="signature", oauth_version="1.0"
     ```

4. **OAuth 2.0 with Proof-of-Possession (PoP)**:
   - **Description**: Instead of using bearer tokens, PoP tokens bind the token to a specific client or session using a cryptographic key, ensuring that the token can only be used by the intended holder. This makes it more secure than a bearer token, as the token alone is not enough; the client also needs to demonstrate knowledge of a secret key.
   - **Example**: The PoP token is cryptographically tied to the client’s session, but the exact format depends on the implementation.

6. **Session Cookies**:
   - **Description**: Instead of passing tokens in the Authorization header, session cookies store a token or session identifier on the client side. These cookies are automatically included in each request made to the server, maintaining the session.
   - **Example**:
     ```http
     Cookie: sessionId=abc123xyz
     ```

7. **SAML (Security Assertion Markup Language)**:
   - **Description**: An XML-based authentication protocol commonly used in Single Sign-On (SSO) systems. It allows secure exchange of authentication and authorization data between an identity provider and a service provider.
   - **Example**: The authentication is usually done by exchanging XML-based assertions, often handled by identity providers like Okta or Google.

</details>

<details>
<summary>Q1-21</summary>

## Q1-21: What is session token?

A **session token** is a unique identifier issued by a server to a client upon a successful login or session creation. It is used to maintain session state between the client and the server. The session token is stored on the client side, typically in a cookie, and sent with each request to identify the session on the server. This allows the server to recognize the user across multiple requests without requiring them to log in again.

### How Session Tokens Work:
1. **User Authentication**:
   - The user provides credentials (like username and password) to log in.
   
2. **Session Token Creation**:
   - If the credentials are correct, the server generates a session token. The session token could be a random string, a signed token (like a JWT), or some other form of unique identifier.
   
3. **Session Token Storage**:
   - The server stores the session token (or a session identifier) in memory or a session store (like Redis or a database), associating it with session data (e.g., user ID, roles, preferences).
   - The session token is sent to the client, usually stored in a cookie.

4. **Client Sends Token in Requests**:
   - For each subsequent request, the client sends the session token back to the server, typically in the HTTP `Cookie` header.
   
5. **Server Validates the Token**:
   - The server retrieves the session data associated with the token and verifies that the session is valid (e.g., it hasn’t expired or been invalidated).

6. **Session Persistence**:
   - As long as the session is valid, the server processes the request and updates any session-related data as needed.

### Session Tokens in .NET Framework and ASP.NET:
In .NET, session tokens are typically managed by the **ASP.NET Session State** mechanism, which provides built-in support for maintaining user sessions.

#### How to Use Session Tokens in .NET:
1. **Session Creation**:
   - In ASP.NET, when a session is created (e.g., upon user login), a unique session ID is automatically generated and associated with the session data.
   - The session ID is stored on the server and the client receives a cookie (e.g., `ASP.NET_SessionId`).
   
   ```csharp
   Session["UserName"] = "JohnDoe";
   ```

2. **Session Token Stored in Cookie**:
   - The session ID is stored in a cookie that is automatically sent with each request to maintain the session.
   - Example cookie in HTTP request:
     ```http
     Cookie: ASP.NET_SessionId=abc123xyz
     ```

3. **Accessing Session Data**:
   - On each request, ASP.NET uses the session ID from the cookie to retrieve the session data stored on the server. This allows you to access session variables.
   
   ```csharp
   var userName = Session["UserName"];
   ```

4. **Session Storage Options**:
   - By default, ASP.NET stores session data **in-memory** on the server. However, this can be customized to store session tokens in a database, distributed cache (like Redis), or in a custom session store.
   
   **In-Memory (default)**:
   ```xml
   <sessionState mode="InProc" timeout="20" />
   ```
   
   **SQL Server** (session data stored in a SQL database):
   ```xml
   <sessionState mode="SQLServer" sqlConnectionString="data source=localhost;user id=sa;password=pass" />
   ```

   **Distributed (using Redis)**:
   ```csharp
   services.AddDistributedRedisCache(options => {
       options.Configuration = "localhost:6379";
   });

   services.AddSession();
   ```

5. **Session Expiration**:
   - The session token can expire based on inactivity or after a predefined timeout period. In ASP.NET, you can set the session timeout in the configuration:
   
   ```xml
   <sessionState timeout="30" />
   ```

6. **Session Authentication with Forms Authentication**:
   - In older versions of ASP.NET, **Forms Authentication** was often used in conjunction with session tokens. After a user logs in, a session token is generated and stored in a cookie to maintain the user’s authenticated session.
   - Example of setting an authentication cookie:
   
   ```csharp
   FormsAuthentication.SetAuthCookie(userName, isPersistent);
   ```

### Session Token vs JWT in .NET Core:
While traditional session tokens rely on server-side storage, **JWT (JSON Web Tokens)** are stateless and do not require server-side storage. In .NET Core, **JWTs** are often used for **authentication** instead of session tokens, especially in **stateless** or **distributed systems**.

#### Example: Using JWT in .NET Core
1. **Generate JWT on Login**:
   - After successful login, you generate a JWT token with user claims:
   
   ```csharp
   var tokenHandler = new JwtSecurityTokenHandler();
   var key = Encoding.ASCII.GetBytes("your-secret-key");
   var tokenDescriptor = new SecurityTokenDescriptor
   {
       Subject = new ClaimsIdentity(new[] {
           new Claim(ClaimTypes.Name, userName)
       }),
       Expires = DateTime.UtcNow.AddHours(1),
       SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
   };
   var token = tokenHandler.CreateToken(tokenDescriptor);
   var tokenString = tokenHandler.WriteToken(token);
   ```

2. **Send JWT in Requests**:
   - The JWT is included in the Authorization header in subsequent requests:
     ```http
     Authorization: Bearer <your-jwt-token>
     ```

3. **Validate JWT on Each Request**:
   - The server validates the token and extracts claims to authenticate the user.

### Summary:
- A **session token** is used to maintain a user’s session on the server, typically stored in a cookie and used to identify requests across multiple interactions.
- In **ASP.NET** and **ASP.NET Core**, session tokens are handled via session state mechanisms, where the session ID is stored in a cookie.
- In modern **stateless** applications, **JWT (JSON Web Tokens)** are often used instead of session tokens for authentication in **.NET Core** due to their simplicity and scalability in distributed environments.

</details>

<details>
<summary>Q1-22</summary>

## Q1-22: What is Signing algorithm?

A **signing algorithm** is a cryptographic method used to create a digital signature for data, ensuring its integrity and authenticity. The signing process involves using a **private key** to generate the signature and a corresponding **public key** to verify it. 

In the context of **JWT (JSON Web Token)** or any secure system, the signing algorithm ensures that the token or data has not been tampered with and can only be verified by the intended parties.

### Key Points of a Signing Algorithm:
1. **Integrity**: Ensures that the data has not been modified after it was signed. If any changes are made, the signature verification will fail.
2. **Authenticity**: Verifies that the data was indeed signed by the rightful party (who holds the private key).
3. **Non-repudiation**: The signer cannot deny having signed the data since only they possess the private key.

### Common Signing Algorithms:
1. **HMAC (Hash-based Message Authentication Code)**:
   - **Algorithm**: `HS256`, `HS384`, `HS512` (HMAC with SHA-256, SHA-384, or SHA-512)
   - **Description**: Symmetric algorithm where the same secret key is used for both signing and verifying the token. Faster but both the sender and receiver must share the same secret.
   - **Use case**: Commonly used in signing **JWT** tokens for web authentication.
   - **Example**:
     ```json
     {
       "alg": "HS256"
     }
     ```

2. **RSA (Rivest-Shamir-Adleman)**:
   - **Algorithm**: `RS256`, `RS384`, `RS512`
   - **Description**: Asymmetric algorithm that uses a pair of keys (a private key for signing and a public key for verifying). The public key is shared openly, while the private key is kept secret.
   - **Use case**: Secure systems where the verifier doesn't need to know the private key (e.g., public key infrastructure).
   - **Example**:
     ```json
     {
       "alg": "RS256"
     }
     ```

3. **ECDSA (Elliptic Curve Digital Signature Algorithm)**:
   - **Algorithm**: `ES256`, `ES384`, `ES512`
   - **Description**: Asymmetric algorithm similar to RSA but uses elliptic curve cryptography, which provides the same level of security with smaller key sizes and more efficient computations.
   - **Use case**: Systems that need high performance and security, often used in mobile devices.
   - **Example**:
     ```json
     {
       "alg": "ES256"
     }
     ```

### How Signing Algorithms Work in JWT:

In a **JWT**, the signing algorithm is specified in the token header. When a JWT is created, the signing algorithm is used to sign the **header** and **payload** of the token, producing a **signature**. This signature ensures that the token has not been tampered with.

1. **Header**:
   ```json
   {
     "alg": "HS256", 
     "typ": "JWT"
   }
   ```

2. **Payload** (data):
   ```json
   {
     "sub": "1234567890",
     "name": "John Doe",
     "admin": true
   }
   ```

3. **Signature**: 
   - The signature is generated by signing the base64-encoded header and payload using the secret key (in the case of `HS256`) or private key (for `RS256` or `ES256`).
   - Example:
     ```http
     HMACSHA256(
       base64UrlEncode(header) + "." + base64UrlEncode(payload),
       secret
     )
     ```

4. **Verification**:
   - When a JWT is received, the server verifies the signature by using the same algorithm and key (secret or public) to recompute the signature. If the signature matches, the token is valid.

### Summary:
A **signing algorithm** is used to create a **digital signature** that ensures data integrity and authenticity. In the case of JWT, common signing algorithms include **HMAC**, **RSA**, and **ECDSA**, each with its own security model. The signature guarantees that the token or data has not been tampered with and allows secure authentication in systems like web applications.

</details>

???
Containers (Docker)
GraphQL
GRPC
open standard
CSRF Token in .Net?
Http vs Https?
Sign in vs Sing on?
SSO?
OAuth?
cryptographic?